var Tortoise = Tortoise || {};
Tortoise.samples = (function () {
  var samples = {
    'rose': [[
      'repeat(18) {',
      '  right(20);',
      '  repeat(36) {',
      '    forward(15);',
      '    right(10);',
      '  }',
      '}'
    ], undefined],
    'square': [[
      'define square(x) {',
      '  repeat(4) {',
      '    forward(x);',
      '    right(90);',
      '  }',
      '}',
      '',
      'square(100);',
      'square(20);'
    ], undefined],
    'spiral': [[
      'define spiral(size) {',
      '  if (size < 30) {',
      '    forward(size);',
      '    right(15);',
      '    var newsize;',
      '    newsize := size * 1.02;',
      '    spiral(newsize);',
      '  }',
      '}',
      '',
      'spiral(5);'
    ], undefined],
    'tree': [[
      'define curve(angle1, angle2, scale, size, count) {',
      '  define draw_curve(size, count) {',
      '    if (count > 0) {',
      '      push();',
      '      forward(size);',
      '      left(angle1);',
      '      draw_curve(size * scale, count - 1);',
      '      right(angle2);',
      '      draw_curve(size * scale * scale, count - 1);',
      '      pop();',
      '    }',
      ' }',
      '  draw_curve(size, count);',
      '}',
      '',
      'up();',
      'left(10);',
      'backward(150);',
      'right(10);',
      'down();',
      'curve(33, 90, 0.80, 89, 8);'
    ], undefined],
    'hilbert': [[
      'var size;',
      'size := 25;',
      'define hilbert (level, angle) {',
      '  if (level > 0) {',
      '    right(angle);',
      '    hilbert(level - 1, 0-angle);',
      '    forward(size);',
      '    left(angle);',
      '    hilbert(level - 1, angle);',
      '    forward(size);',
      '    hilbert(level - 1, angle);',
      '    left(angle);',
      '    forward(size);',
      '    hilbert(level - 1, 0-angle);',
      '    right(angle);',
      '  }',
      '}',
      '',
      'up();',
      'backward(190);',
      'right(90);',
      'backward(190);',
      'left(90);',
      'down();',
      'hilbert(4, 90);',    
    ], undefined],
    'maze': [[
      'define wall(size, length) {',
      '  var gap;',
      '  gap := floor(random() * length);',
      '  push();',
      '  down();',
      '  forward(size * gap);',
      '  up();',
      '  forward(size);',
      '  down();',
      '  forward(size * ((length - gap) - 1));',
      '  up();',
      '  pop();',
      '}',
      '',
      'define bisect(size, width, height) {',
      '  if (width > 1) {',
      '    if (height > 1) {',
      '      if (width >= height) {',
      '        var split;',
      '        split := floor(random() * (width - 1) + 1);',
      '        bisect(size, split, height);',
      '        push();',
      '        right(90);',
      '        forward(size * split);',
      '        left(90);',
      '        wall(size, height);',
      '        bisect(size, width - split, height);',
      '        pop();',
      '      }',
      '      if (height > width) {',
      '        var split;',
      '        split := floor(random() * (height - 1) + 1);',
      '        bisect(size, width, split);',
      '        push();',
      '        forward(size * split);',
      '        right(90);',
      '        wall(size, width);',
      '        left(90);',
      '        bisect(size, width, height - split);',
      '        pop();',
      '      }',
      '    }',
      '  }',
      '}',
      '',
      'define maze(size, width, height) {',
      '  repeat(2) {',
      '    up();',
      '    forward(size);',
      '    down();',
      '    forward(size * (height - 1));',
      '    right(90);',
      '    forward(size * width);',
      '    right(90);',
      '  }',
      '  up();',
      '  bisect(size, width, height);',
      '  down();',
      '}',
      '',
      'up();',
      'backward(190);',
      'right(90);',
      'backward(190);',
      'left(90);',
      '',
      'maze(38, 10, 10);',
    ], undefined],
  };
  for (var name in samples) { if (samples.hasOwnProperty(name)) {
    samples[name][0] = samples[name][0].join('\n');
  }}
  return samples;
}());
if (typeof module !== "undefined") { module.exports = Tortoise.samples; }